# Java面试题汇总

## 基本概念

### 面向对象的三个特征

封装、继承和多态是面向对象的三大特征

### 多态的好处

多态定义：允许不同对象对同一消息（发送消息也就是函数调用）做出响应，也就是同一个消息可以根据发送对象的不同而采用不同的行为方式

优点：

- 可替换性：多态对已经存在的代码具有可替换性
- 可扩充性：增加新的子类不会影响已存在的类结构
- 接口性：多态是超类通过方法签名向子类提供一个公共接口，有子类来完善或者重写来实现的。
- 灵活性以及简化性

#### 代码中实现多态

1. 接口实现
2. 继承父类重写方法
3. 同一个类中进行重载

#### 虚拟机中实现多态方式

通过动态把绑定技术（dynamic binding），执行期间判断引用对象的实际类型，根据实际类型调用对应的方法。

### 接口的意义

规范、扩展、回调

### 抽象类的意义

- 为其他子类提供一个公共的类型
- 封装子类中重复定义的内容
- 定义抽象方法，子类虽然有不同的实现但是定义时是一致的

### 接口和抽象类的区别

| 比较           | 抽象类                                                       | 接口                                                       |
| -------------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 默认方法       | 抽象类中可以有默认的方法实现                                 | Java8之前不存在方法的实现                                  |
| 实现方式       | 子类使用extends关键字继承抽象类，如果子类不是抽象类则子类需要提供抽象类中所声明的方法实现 | 子类使用implements来实现接口，需要提供接口中所有声明的实现 |
| 构造器         | 抽象类中可以有构造器                                         | 接口不能存在构造器                                         |
| 与正常类的区别 | 抽象类不能被实例化                                           | 接口是完全不同的类型                                       |
| 访问修饰符     | 抽象方法可以有public，protected以及default等修饰符           | 接口中默认是public修饰符，并且不能使用其他修饰符           |
| 多继承         | 一个子类只能存在一个父类                                     | 一个子类可以实现多个接口                                   |
| 添加新的方法   | 在抽象类中添加新的方法，也可以提供默认的实现，也就是说不需要修改子类中现有的代码 | 如果要往接口中添加新的方法，则子类中需要实现该方法         |

### 父类的静态方法能否被子类重写

不能！重写只适用于实例方法，不能用于静态方法，而子类当中含有和父类相同签名的静态方法一般称为隐藏。

### 什么是不可变对象

不可变对象指的是对象一旦被创建，状态就不能再改变，任何的修改都会创建一个新的对象，比如string、Integer以及其他的封装类。

### 静态变量和实例变量的区别

静态变量存储在方法区，属于类所有；实例变量存储在堆里面，其引用存在于当前线程栈。

### 能否创建一个包含可变对象的不可变对象？

可以，可以创建一个包含可变对象的不可变对象，但是不能共享可变对象的引用，如果需要变化的时候，需要返回源对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。

### Java创建对象的几种方式

- 采用new关键字
- 通过反射
- 采用clone
- 通过序列化的机制

前面两个是显示的调用构造方法。造成耦合性最高的是new关键字，所以解耦必须要减少new的使用。

### switch 中能否使用string做参数

在jdk1.7之前，switch只能支持byte、short、char、int或者对应的封装类和enum类型，9种

在jdk1.7之后，开始支持string了，10种

### switch能否作用在byte，long上

可以作用在byte上，不能作用在long上（可以理解为在基本类型中int可默认类型转换的行）

### String s1=”ab”, String s2=”a”+”b”, String s3=”a”, String s4=”b”, s5=s3+s4 请问s5==s2 返回什么？
返回：false，在编译过程中，编译器会将s2优化为"ab"，也就是会放入常量池中，但是s5则是创建在堆区，相当于string s5 = new string("ab")。

### string对象的intern()

intern()方法会首先从常量池中查找是否存在该常量值，如果存在的话直接返回，不存在的话则现在在常量池中创建。

比如：

```java
String ss1 = "aa";
        String ss2 = ss1.intern();
        System.out.println("ss1 == ss2:" + (ss1 == ss2));//true

        String ss3 = new String("bb");
        String ss4 = ss3.intern();
        System.out.println("ss3 == ss4:" + (ss3 == ss4));//false,此时不是在常量池中的，所以会不相等
```

### object中的公共方法

equals:

clone:
getClass:

notify,notifyAll,wait

toString

### java 中的四种引用

强引用，软引用，弱引用，虚引用，不同的引用类型主要体现在GC上面：

- 强引用：如果一个对象具有强引用，就不会被垃圾回收期回收。即时当前内存空间不足，jvm也不会回收他而是抛出outofmemoryError错误，使程序异常终止。如果想要中断强引用和某个对象之间的关联，可以显示的将引用赋值为null，这样一来jvm就会在合适的时间回收该对象。
- 软引用：在使用软引用的时候，如果内存的空间足够，软引用就会继续被使用，而不会被垃圾回收器回收，只有在内存不足的时候，软引用才会被垃圾回收器回收。
- 弱引用：具有弱引用的对象拥有的生命周期更加短暂。因为JVM会进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收（下一次垃圾回收时）。不过由于垃圾回收是一个优先级低的线程，所以并不一定会迅速发现弱引用对象。
- 虚引用：虚引用形同虚设，如果一个对象仅仅持有虚引用，那么它相当于没有引用，任何时候都可能被垃圾回收器回收。

### WeakReference和SoftReference区别

虽然两种引用都有利于提高GC和内存的效率，但是WeakReference（弱引用）一旦失去最后一个强引用就会被GC回收，而软引用虽然不能阻止被回收，但是可以延迟到JVM内存不足的时候。

### 为什么要有不同的引用类型？

因为Java不像c语言可以控制内存的申请和释放，在Java中有时候需要控制对象被回收的时机，因此就诞生了不同的引用类型，可以说不同的引用类型实际上是对GC回收时机不可控的妥协，下面场景：

- 利用软引用和弱引用可以解决OOM问题：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，当内存不足的时候，JVM会自动回收这些缓存图片对象所占用的空间，从而有效避免OOM的问题。
- 通过软引用实现Java对象的高速缓存：比如说创建了一系列Person的类，如果每次需要查询一个人的信息，哪怕是几秒钟之前查询过的，都需要重新构建一个实例，这样会引起大量Person对象的消耗，并且由于这些对象的生命周期相对较短，会引起多次GC影响性能。此时通过软引用和HashMap的结合可以构造高速缓存，提高性能。

### Java中的 == 和equals区别，equals和'hashCode'区别

== 是一个运算符，用于比较两个变量是否相等，而equals是Object类的方法，用于比较两个对象是否相等。默认Object类的equals方法是比较两个对象的地址，此时和==的效果一样。换句话说：基本类型比较用 == ，比较而是他们的值。默认下对象使用==比较的时候比较的是内存地址，如果需要比较对象内容，需要重写equals方法。

- equals和hashCode的区别：

  hashCode是Object类的一个方法，返回的是一个哈希值。如果两个对象根据equals方法比较相等，那么这俩个对象中任意一个对象的hashCode方法必须产生相同的哈希值。如果两个对象根据equals方法比较不相等，那么产生的哈希值不一定会相等（存在碰撞的情况下会相等）

- a.hashCode有什么用？与a.equals(b)有什么关系？

  hashCode方法是相应对象整形的hash值，通常基于hash的集合类，与equals方法关系密切。根据Java的规范，使用equals方法判断两个相等的对象必须具有相同的hashcode。

  将对象放入到集合中，首先判断要放入对象的hashCode是否已经在集合中存在，不存在的话就直接放入集合中，如果hashCode相等就通过equals方法判断要放入对象与集合中的任何对象相等，如果equals不相等直接将元素放入集合中，否则不放入。

- 不相等对象具有相同的hashCode

  有可能，两个不相等的对象可能会有相同的hashCode值，也就是hashmap产生冲突的原因，如果两个对象相等，必须有相同的hashcode值，反之不成立。

- 可以在hashCode中使用随机数字吗？

  不能，因为同一对象的hashcode值必须是相同的

- a == b 与a.equals(b)有什么区别？如果a和b都是对象，则a == b是比较两个对象的引用，只有当a和b指向的是堆中的同一个对象才会返回true，而a.equals(b)是进行逻辑比较，所以通常需要重写该方法来提供一致性的比较。

### 3*0.1 == 0.3返回值是什么？

  false，因为有些浮点数不能完全精确表示出来

### a = a+b 与a+=b有什么区别吗？

+=操作符会进行隐式的自动类型转换，此处a+=b隐式的将+操作的结果强制转换为持有结果的类型，但是a=a+b则不会自动进行类型转换。如：

byte a = 127;
byte b = 127;
b = a + b; // error : cannot convert from int to byte （这里a+b会被自动提升为int类型）
b += a; // ok

short s1= 1; s1 = s1 + 1; 该段代码是否有错,有的话怎么改？
有错误，short 类型在进行运算时会自动提升为int 类型，也就是说s1+1 的运算结果是int
类型。
short s1= 1; s1 += 1; 该段代码是否有错，有的话怎么改？
+=操作符会自动对右边的表达式结果强转匹配左边的数据类型，所以没错。

### & 和&&的区别

一个是位操作一个是逻辑运算。逻辑运算具有短路的特征，&不具有短路特征

### 一个Java文件内的类

只能有一个public公共类，但是可以有多个default修饰的类

### 内部类的作用

内部类可以有多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立，在单个外围类当中，可以让多个内部类以不同的方式实现同一个接口或者继承同一个类，创建内部类对象的时刻不依赖于外部类对象的创建。内部类是一个独立的实体。

内部类提供了更好的封装除了该外围类，其他的类都不能访问。

### final , finalize , finally的不同之处

final是一个修饰符，可以用于修饰变量、方法、和类。如果修饰的是变量，说明该变量的值在初始化之后不能被改变。finalize方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用finalize没有保证。finally是一个关键字，和try以及catch一起用于处理异常。finally块一定会被执行，无论try块中是否发生了异常。

### clone是哪个类的方法？

java.lang.Cloneable是一个标识性的接口，不包含任何的方法，clone方法在object类中定义。并且clone方法是一个本地方法，也就是由其他语言实现的。

### 深拷贝和浅拷贝的区别是什么？

- 浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不是复制他引用的对象。
- 深拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向被复制过的新对象而不是原有的那些被引用的对象。换言之，深拷贝需要把要复制对象所引用的对象也都复制一遍。

### static都有哪些用法？

1. 静态方法（被static修饰的所有变量以及方法都是类的静态资源，被类的实例所共享）

   

2. 静态变量

3. 静态代码块：多用于初始化操作

4. 静态内部类：修饰内部类

5. 静态导包：import static *** ，可以用来指定导入某个类中的静态资源，并且不需要使用类名。资源名，可以直接使用。

### final的用法

1. 被final修饰的类不可以被继承

2. 被final修饰的方法不可以被重写

3. 被final修饰的变量不可以被改变。如果修饰引用，则表示引用不可变，引用指向的内容可变

4. 被final修饰的方法，JVM会尝试将其内联以提高运行效率

5. 被final修饰的常量，在编译期间会存入常量池中

   编译器对final域需要遵守的两个重排序规则：

   1. 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不可以重排序。
   2. 初次读一个包含final域的对象的引用，与随后初次都这个final域俩个操作之间不能重排序。

## 数据类型相关

### Java中的int,char,long等数据类型各占多少个字节？



| 类型   | 位数 | 字节数 |
| ------ | ---- | ------ |
| short  | 16   | 2      |
| int    | 32   | 4      |
| long   | 64   | 8      |
| float  | 32   | 4      |
| double | 64   | 8      |
| char   | 16   | 2      |

  在不同位数的jvm虚拟机中，类型变量的长度是一个固定值，与平台无关。

### int与Integer的区别

Integer是int的包装类型，在拆箱与装箱中，二者自动转换。int是基本类型，直接存数值，而Integer是一个对象，用一个引用指向这个对象。

### int与Integer哪个占用的内存更多

Integer对象会占用更多的内存 。Integer是一个对象，需要存储对象的元数据。但是int是一个原始类型的数据，所以占用的空间更少。



